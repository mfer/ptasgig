---data structures
square
level
set
disk
integer
table
table_entry

---algorythms
gig_OF_level_INTERSECTING_square
set_ARE_DISJOINT
set_INTERSECTS_square
table_ON_square_OF_set
set_IS_CONTAINED_IN_square
set_INTERSECTS_BOUNDARY_OF_square

set_UNION_set
UNDEFINE
table_IS_UNDEFINED
table_ON_square_AND_set_OF_square_AND_set

_______________________________________________________________________

---algorythm 2.4-first-try
for ALL_J
	AT_ON_S_AND_I_OF_Sprime_gh_AND_J = UNDEFINE
Q = D_rs_OF_j_INTERSECTING_Sprime_gh
for ALL_U_SUBSET_OF_Q_WITH_SIZEOF_U_<=_C_*+k^2 do
	if I_UNION_U_ARE_DISJOINT then
		Iprime = I_INTERSECTS_Sprime_gh
		X = T_ON_Sprime_gh_OF_Iprime_UNION_U
		X = X_UNION_U_IS_CONTAINED_IN_Sprime_gh
		J = U_INTERSECTS_BOUNDARY_OF_Sprime_gh
		if AT_ON_S_AND_I_OF_Sprime_gh_AND_J_IS_UNDEFINED or
			w(X)_>_w(AT_S_AND_I_Sprime_gh_AND_J) then
				AT_ON_S_AND_I_OF_Sprime_gh_AND_J = X
		fi
	fi
od

_______________________________________________________________________

---signatures
int size(set)
int weight(set)
set boundary(set,sub_square)
set contained(set,sub_square)
set disjoint(set)
set disjoint(set,set)
set get_aux_set(square,set,sub_square,set,set)
set get_set(set)
set intersects(set,square)
set intersects(set,sub_square)
set level(gig,int)
set union(set,set)
square new_square(int,int,int,int)
sub_square new_sub_square(int,int,square)
void init_aux_set(square,set,sub_square)
void update_aux_set(square,set,sub_square,set,set)


float min_diameter(gig)
set gig2set(gig,int,int,int)

---algorythm 2.4-almost-there-again!
INPUT:
	int k
	gig G
		//D(r,s) // activelines r,s 
		//Disks with diameters already scaled so that the largest disk has diameter 1

L = floor(log_{k+1}(1./min_diameter(Drs)))

for 0_<=_j_<=_L do
    for 0_<=_r,s_<_k do

		left,down,right,up = getsquare(D,j,r,s)
		S = new_square(left,down,right,up)

		I = disjoint(intersects(level(D,j),S))
		for 0<=g,h<=k do
			Sprime = new_sub_square(g,h,S)
			init_aux_set(S,I,Sprime)
			Q = intersects(D,Sprime)
			for ALL_U_SUBSET_OF_Q_WITH_SIZEOF_U_<=_C_*+k^2 do
				if size(disjoint(I,U)) > 0 then
					Iprime = intersects(I,Sprime)
					X = get_set(union(Iprime,U))
					X = union(X,contained(U,Sprime))
					J = boundary(U,Sprime)
					if size(get_aux_set(S,I,Sprime,J)) == 0 || weight(X) > weight(AT) then
						update_aux_set(S,I,Sprime,J,X)
					fi
				fi
			od
		od
	od
od
